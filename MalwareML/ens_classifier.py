import os
import logging
import datetime
import numpy as np

from sklearn.externals import joblib
from sklearn.linear_model import LogisticRegression
from sklearn.model_selection import train_test_split
from sklearn.neural_network import MLPClassifier

from classifier import Classifier
from sk_classifier import SkClassifier
from keras_classifier import KerasClassifier

logger = logging.getLogger(__name__)


def get_inv_indices(indices):
    inv = np.empty(len(indices), dtype=np.int)
    inv[indices] = np.arange(len(indices))
    return inv


class EnsClassifier(Classifier):
    type_map = dict(
        Classifier.type_map,
        meta_classifier = str,
        pca_op = bool,
    )

    meta_classifiers = {
        'logistic': {
            'build': lambda self: LogisticRegression()
        },
        'mlp': {
            'build': lambda self: MLPClassifier(solver='lbfgs', alpha=1e-5, hidden_layer_sizes=(5, 2), random_state=42),
        },
    }

    def __init__(self, meta_classifier='mlp', pca_op=False, **kwargs):
        super().__init__(**kwargs)

        logging.info('Initializing Ensemble classifier')
        self.meta_classifier = meta_classifier
        self.pca_op = pca_op

        additional_params = {}
        mlp_params = {}
        pca_params = dict(fr_type='PCA', fr_preferred_size=250, fr_max_size=-1, fr_string='DYNAMIC_OPCODE_')
        if self.pca_op:
            logging.debug('Using PCA for MLP in ensemble')
            additional_params['feature_exclude_patterns'] = ['DYNAMIC_OPCODE_COUNT']
            mlp_params.update(pca_params)

        self.classifiers = [
            KerasClassifier(classifier_name='mlp', cv=4, epochs=100, batch_size=128, validation_split=0.05,
                            patience=15, early_stopping=True, **mlp_params,
            ),
            SkClassifier(classifier_name='rf', cv=4, n_estimators=300, n_jobs=self.n_jobs, **additional_params),
            SkClassifier(classifier_name='rf', cv=4, n_estimators=300, n_jobs=self.n_jobs, **additional_params),
            SkClassifier(classifier_name='rf', cv=4, n_estimators=300, n_jobs=self.n_jobs, **additional_params),
            SkClassifier(classifier_name='et', cv=4, n_estimators=100, n_jobs=self.n_jobs, **additional_params),
            SkClassifier(classifier_name='et', cv=4, n_estimators=200, n_jobs=self.n_jobs, **additional_params),
            SkClassifier(classifier_name='et', cv=4, n_estimators=300, n_jobs=self.n_jobs, **additional_params),
            SkClassifier(classifier_name='knn', cv=4, n_neighbors=2, n_jobs=self.n_jobs, **additional_params),
            SkClassifier(classifier_name='knn', cv=4, n_neighbors=5, n_jobs=self.n_jobs, **additional_params),
            SkClassifier(classifier_name='rnn', cv=4, radius=1, outlier_label=0, n_jobs=self.n_jobs, **additional_params),
            SkClassifier(classifier_name='rnn', cv=4, radius=5, outlier_label=0, n_jobs=self.n_jobs, **additional_params),

            #SkClassifier(classifier_name='knn', cv=4, n_neighbors=1, n_jobs=self.n_jobs),
            #SkClassifier(classifier_name='knn', cv=4, n_neighbors=2, n_jobs=self.n_jobs),
            #SkClassifier(classifier_name='knn', cv=4, n_neighbors=5, n_jobs=self.n_jobs),

            #SkClassifier(classifier_name='knn', cv=4, n_neighbors=2, n_jobs=self.n_jobs),
            #SkClassifier(classifier_name='svm-rbf', cv=4, c=10),
        ]

    def save_model(self, output_dir):
        """
        Calls the save_model methods on each classifier with a subdirectory
        """
        os.makedirs(output_dir, exist_ok=True)
        self.save_matrix_transformers(output_dir)

        logging.info('Saving {} classifiers to subdirectories in {}'.format(len(self.classifiers), output_dir))
        for i, classifier in enumerate(self.classifiers):
            classifier.save_model(os.path.join(output_dir, 'classifier_{}'.format(i)))

        logging.info('Saving meta classifier to {}'.format(output_dir))
        joblib.dump(self.mclf, os.path.join(output_dir, 'mclf.pkl'))

    def load_model(self, model_dir):
        """
        Calls the load_model methods on each classifier with a subdirectory
        """
        self.load_matrix_transformers(model_dir)

        logging.info('Loading {} classifiers from subdirectories in {}'.format(len(self.classifiers), model_dir))
        for i, classifier in enumerate(self.classifiers):
            classifier.load_model(os.path.join(model_dir, 'classifier_{}'.format(i)))

        logging.info('Loading meta classifier from {}'.format(model_dir))
        self.mclf = joblib.load(os.path.join(model_dir, 'mclf.pkl'))

    def test(self, feature_matrix, truths, reports=None, train_indices=None, test_indices=None, feature_weights=None, test_size=0.25,
             predict_function='predict_proba', param_overrides=None, use_best_params=False):

        logging.info('Predicting training samples with classifiers for ensemble')
        x_train, x_test, y_train, y_test, _, test_indices = train_test_split(
            feature_matrix, truths, range(len(truths)), test_size=test_size, stratify=truths
        )

        prediction_features = np.zeros((len(x_train), len(self.classifiers)))
        for i, classifier in enumerate(self.classifiers):
            logging.debug('[{}] Predicting training samples with classifier {}'.format(datetime.datetime.now(), i))
            classifier.vec = self.vec
            classifier.feature_map = self.feature_map
            x_train_filtered = classifier.filter_feature_matrix(x_train)
            predictions, indices = classifier.test(x_train_filtered, y_train)
            #predictions = predictions[get_inv_indices(indices)]
            prediction_features[:, i][indices] = predictions
            self._post_loop_cleanup()

        logging.info('Fitting meta classifier')
        self.mclf = self.meta_classifiers[self.meta_classifier]['build'](self)
        self.mclf.fit(prediction_features, y_train)

        logging.info('Training and predicting test set for ensemble')
        prediction_features = np.zeros((len(x_test), len(self.classifiers)))
        for i, classifier in enumerate(self.classifiers):
            logging.debug('[{}] Training and predicting test set with classifier {}'.format(datetime.datetime.now(), i))
            classifier.feature_map = self.feature_map
            x_train_filtered = classifier.filter_feature_matrix(x_train)
            classifier.train(x_train_filtered, y_train)
            classifier.feature_map = self.feature_map
            x_test_filtered = classifier.filter_feature_matrix(x_test)
            predictions = classifier.get_predictions(x_test_filtered)
            prediction_features[:, i] = predictions
            self._post_loop_cleanup()

        logging.info('Predicting test set with meta classifier')
        predictions = getattr(self.mclf, predict_function)(prediction_features)

        return predictions, test_indices

    def train(self, feature_matrix, truths, feature_weights=None, use_best_params=False):
        """
        Train classifier with feature_matrix and truths
        """
        logging.info('Predicting training samples with classifiers for ensemble')
        prediction_features = np.zeros((len(feature_matrix), len(self.classifiers)))
        for i, classifier in enumerate(self.classifiers):
            logging.debug('Predicting all samples with classifier {}'.format(i))
            classifier.vec = self.vec
            classifier.imp = self.imp  # Passed in so save works correctly
            classifier.feature_map = self.feature_map
            feature_matrix_filtered = classifier.filter_feature_matrix(feature_matrix)
            predictions, indices = classifier.test(feature_matrix_filtered, truths)
            prediction_features[:, i][indices] = predictions
            self._post_loop_cleanup()

        logging.info('Fitting meta classifier')
        self.mclf = self.meta_classifiers[self.meta_classifier]['build'](self)
        self.mclf.fit(prediction_features, truths)

        logging.info('Training individual classifiers')
        for i, classifier in enumerate(self.classifiers):
            logging.debug('Training classifier {}'.format(i))
            classifier.feature_map = self.feature_map
            feature_matrix_filtered = classifier.filter_feature_matrix(feature_matrix)
            classifier.train(feature_matrix_filtered, truths)
            self._post_loop_cleanup()

        return self.classifiers

    def get_predictions(self, feature_matrix, feature_weights=None):
        """
        Get predictions using existing classifier. Returns array of (class for each report)
        """
        logging.info('Predicting classes using classifiers')
        prediction_features = np.zeros((len(feature_matrix), len(self.classifiers)))
        for i, classifier in enumerate(self.classifiers):
            logging.debug('Predicting with classifier {}'.format(i))
            classifier.feature_map = self.feature_map
            feature_matrix_filtered = classifier.filter_feature_matrix(feature_matrix)
            predictions = classifier.get_predictions(feature_matrix_filtered)
            prediction_features[:, i] = predictions
            self._post_loop_cleanup()

        logging.info('Predicting classes using meta classifier')

        predictions = self.mclf.predict(prediction_features)
        return predictions

    def get_probabilities(self, feature_matrix, log_proba=False):
        logging.info('Predicting classes using classifiers')
        prediction_features = np.zeros((len(feature_matrix), len(self.classifiers)))
        for i, classifier in enumerate(self.classifiers):
            logging.debug('Predicting with classifier {}'.format(i))
            classifier.feature_map = self.feature_map
            feature_matrix_filtered = classifier.filter_feature_matrix(feature_matrix)
            predictions = classifier.get_predictions(feature_matrix_filtered)
            prediction_features[:, i] = predictions
            self._post_loop_cleanup()

        logging.info('Predicting classes using meta classifier')
        predictions = self.mclf.predict_proba(prediction_features)

        return predictions
